<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Telegotchi</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            background-color: #f5f5f5;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            color: #333;
        }

        .container {
            width: 100%;
            max-width: 400px;
            background-color: white;
            border-radius: 15px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            padding: 20px;
            margin: 20px 0;
        }

        h1 {
            color: #2b7de9;
            text-align: center;
            margin-bottom: 20px;
        }

        .pet-container {
            background-color: #e9f5ff;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            margin-bottom: 20px;
            position: relative;
        }

        .pet-image {
            font-size: 80px;
            margin: 10px 0;
        }

        .pet-level {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: #2b7de9;
            color: white;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 15px 0;
        }

        .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .stat-bar {
            width: 100%;
            height: 10px;
            background-color: #e0e0e0;
            border-radius: 5px;
            margin-top: 5px;
            overflow: hidden;
        }

        .stat-fill {
            height: 100%;
            background-color: #4caf50;
        }

        .hunger .stat-fill {
            background-color: #ff9800;
        }

        .happiness .stat-fill {
            background-color: #e91e63;
        }

        .energy .stat-fill {
            background-color: #2196f3;
        }

        .cleanliness .stat-fill {
            background-color: #9c27b0;
        }

        .money {
            font-weight: bold;
            color: #4caf50;
            margin: 10px 0;
            font-size: 18px;
        }

        .buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }

        button {
            background-color: #2b7de9;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #1a5cb8;
        }

        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        .work-button {
            background-color: #ff9800;
        }

        .work-button:hover {
            background-color: #e68a00;
        }

        .shop-button {
            background-color: #9c27b0;
        }

        .shop-button:hover {
            background-color: #7b1fa2;
        }

        .sleep-button {
            background-color: #673ab7;
        }

        .sleep-button:hover {
            background-color: #5e35b1;
        }

        .clean-button {
            background-color: #009688;
        }

        .clean-button:hover {
            background-color: #00897b;
        }

        .event-button {
            background-color: #ff5722;
        }

        .event-button:hover {
            background-color: #e64a19;
        }

        .revive-button {
            background-color: #4caf50;
        }

        .revive-button:hover {
            background-color: #3d8b40;
        }

        .reset-button {
            background-color: #f44336;
        }

        .reset-button:hover {
            background-color: #d32f2f;
        }

        .shop {
            display: none;
            background-color: #f9f9f9;
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
        }

        .shop-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid #eee;
        }

        .shop-item:last-child {
            border-bottom: none;
        }

        .collection {
            margin-top: 20px;
        }

        .collection-items {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }

        .collection-item {
            width: 50px;
            height: 50px;
            background-color: #e0e0e0;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            position: relative;
        }

        .collection-item.owned {
            background-color: #ffeb3b;
            border: 2px solid #ffc107;
        }

        .collection-count {
            position: absolute;
            bottom: 2px;
            right: 2px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #4caf50;
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            z-index: 100;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .notification.show {
            opacity: 1;
        }

        .notification.error {
            background-color: #f44336;
        }

        .notification.warning {
            background-color: #ff9800;
        }

        .pet-evolution {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 10px;
            z-index: 10;
            animation: fadeIn 0.5s;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        .tabs {
            display: flex;
            margin-bottom: 10px;
            border-bottom: 1px solid #ddd;
        }

        .tab {
            padding: 10px 15px;
            cursor: pointer;
            border-bottom: 2px solid transparent;
        }

        .tab.active {
            border-bottom: 2px solid #2b7de9;
            font-weight: bold;
        }

        .shop-content {
            display: none;
        }

        .shop-content.active {
            display: block;
        }

        .minigame-container {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .minigame {
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            max-width: 300px;
        }

        .minigame-button {
            margin: 10px;
            padding: 10px 20px;
            font-size: 16px;
        }

        .progress-container {
            width: 100%;
            background-color: #e0e0e0;
            border-radius: 5px;
            margin: 10px 0;
        }

        .progress-bar {
            height: 20px;
            background-color: #4caf50;
            border-radius: 5px;
            width: 0%;
            transition: width 0.3s;
        }

        .death-timer {
            margin-top: 10px;
            font-size: 12px;
            color: #666;
        }

        .death-timer.warning {
            color: #f44336;
            font-weight: bold;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            max-width: 300px;
        }

        .modal-input {
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            border: 1px solid #ddd;
            border-radius: 5px;
        }

        .modal-button {
            margin: 10px 5px;
            padding: 10px 20px;
            font-size: 16px;
        }

        .death-screen {
            text-align: center;
            margin-top: 20px;
        }

        .death-screen h2 {
            color: #f44336;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>Telegotchi</h1>

        <div class="pet-container" id="petContainer">
            <div class="pet-level" id="petLevel">1</div>
            <div class="pet-image" id="petImage"><canvas id="creatureCanvas"></canvas></div>
            <h2 id="petName">Huevo Telegotchi</h2>
            <div class="money">💰 $<span id="moneyAmount">50</span></div>

            <div class="stats">
                <div class="stat hunger">
                    <span>Hambre</span>
                    <div class="stat-bar">
                        <div class="stat-fill" id="hungerBar" style="width: 100%;"></div>
                    </div>
                </div>
                <div class="stat happiness">
                    <span>Felicidad</span>
                    <div class="stat-bar">
                        <div class="stat-fill" id="happinessBar" style="width: 100%;"></div>
                    </div>
                </div>
                <div class="stat energy">
                    <span>Energía</span>
                    <div class="stat-bar">
                        <div class="stat-fill" id="energyBar" style="width: 100%;"></div>
                    </div>
                </div>
                <div class="stat cleanliness">
                    <span>Limpieza</span>
                    <div class="stat-bar">
                        <div class="stat-fill" id="cleanlinessBar" style="width: 100%;"></div>
                    </div>
                </div>
            </div>
            <div class="death-timer" id="deathTimer"></div>

            <div class="death-screen" id="deathScreen" style="display: none;">
                <h2>¡Tu Telegotchi ha muerto!</h2>
                <p id="deathMessage"></p>
                <button class="revive-button" id="reviveButton">Revivir por $1000</button>
                <button class="reset-button" id="resetButton">Comenzar de nuevo</button>
            </div>
        </div>

        <div class="buttons" id="actionButtons">
            <button id="feedButton">Alimentar ($10)</button>
            <button id="playButton">Jugar</button>
            <button class="work-button" id="workButton">Trabajar (+$15)</button>
            <button class="sleep-button" id="sleepButton">Dormir</button>
            <button class="clean-button" id="cleanButton">Limpiar ($5)</button>
            <button class="shop-button" id="shopButton">Tienda</button>
            <button class="event-button" id="eventButton" style="display: none;">Evento Diario!</button>
        </div>

        <div class="shop" id="shop">
            <div class="tabs">
                <div class="tab active" data-tab="food">Comida</div>
                <div class="tab" data-tab="energy">Energía</div>
                <div class="tab" data-tab="cleanliness">Limpieza</div>
                <div class="tab" data-tab="collectibles">Coleccionables</div>
            </div>

            <div class="shop-content active" id="food-shop">
                <div class="shop-item">
                    <span>🥕 Vegetales ($10)</span>
                    <button class="buy-item" data-type="food" data-cost="10" data-value="20">Comprar</button>
                </div>
                <div class="shop-item">
                    <span>🍎 Frutas ($20)</span>
                    <button class="buy-item" data-type="food" data-cost="20" data-value="40">Comprar</button>
                </div>
                <div class="shop-item">
                    <span>🍗 Pollo ($30)</span>
                    <button class="buy-item" data-type="food" data-cost="30" data-value="60">Comprar</button>
                </div>
                <div class="shop-item">
                    <span>🍔 Comida rápida ($15)</span>
                    <button class="buy-item" data-type="food" data-cost="15" data-value="30"
                        data-cleanliness="-10">Comprar</button>
                </div>
            </div>

            <div class="shop-content" id="energy-shop">
                <div class="shop-item">
                    <span>☕ Café ($20)</span>
                    <button class="buy-item" data-type="energy" data-cost="20" data-value="30">Comprar</button>
                </div>
                <div class="shop-item">
                    <span>🍵 Té ($15)</span>
                    <button class="buy-item" data-type="energy" data-cost="15" data-value="20">Comprar</button>
                </div>
                <div class="shop-item">
                    <span>⚡ Bebida energética ($40)</span>
                    <button class="buy-item" data-type="energy" data-cost="40" data-value="60"
                        data-happiness="10">Comprar</button>
                </div>
                <div class="shop-item">
                    <span>💊 Vitaminas ($50)</span>
                    <button class="buy-item" data-type="energy" data-cost="50" data-value="40"
                        data-hunger="10">Comprar</button>
                </div>
            </div>

            <div class="shop-content" id="cleanliness-shop">
                <div class="shop-item">
                    <span>🧼 Jabón ($10)</span>
                    <button class="buy-item" data-type="cleanliness" data-cost="10" data-value="30">Comprar</button>
                </div>
                <div class="shop-item">
                    <span>🚿 Champú ($20)</span>
                    <button class="buy-item" data-type="cleanliness" data-cost="20" data-value="50">Comprar</button>
                </div>
                <div class="shop-item">
                    <span>🧴 Loción ($30)</span>
                    <button class="buy-item" data-type="cleanliness" data-cost="30" data-value="70"
                        data-happiness="10">Comprar</button>
                </div>
                <div class="shop-item">
                    <span>🧽 Spa de lujo ($100)</span>
                    <button class="buy-item" data-type="cleanliness" data-cost="100" data-value="100"
                        data-happiness="20">Comprar</button>
                </div>
            </div>

            <div class="shop-content" id="collectibles-shop">
                <div class="shop-item">
                    <span>🏆 Trofeo ($500)</span>
                    <button class="buy-item" data-type="collectible" data-cost="500" data-id="1">Comprar</button>
                </div>
                <div class="shop-item">
                    <span>💎 Diamante ($1000)</span>
                    <button class="buy-item" data-type="collectible" data-cost="1000" data-id="2">Comprar</button>
                </div>
                <div class="shop-item">
                    <span>👑 Corona ($2000)</span>
                    <button class="buy-item" data-type="collectible" data-cost="2000" data-id="3">Comprar</button>
                </div>
                <div class="shop-item">
                    <span>🎮 Consola ($1500)</span>
                    <button class="buy-item" data-type="collectible" data-cost="1500" data-id="4">Comprar</button>
                </div>
                <div class="shop-item">
                    <span>🏡 Casa ($5000)</span>
                    <button class="buy-item" data-type="collectible" data-cost="5000" data-id="5">Comprar</button>
                </div>
            </div>
        </div>

        <div class="collection">
            <h3>Tu Colección</h3>
            <div class="collection-items" id="collectionItems">
                <!-- Los coleccionables aparecerán aquí -->
            </div>
        </div>
    </div>

    <div class="minigame-container" id="minigameContainer">
        <div class="minigame">
            <h2 id="minigameTitle">Evento Diario</h2>
            <p id="minigameDescription">¡Completa el minijuego para ganar premios!</p>
            <div class="progress-container">
                <div class="progress-bar" id="minigameProgress"></div>
            </div>
            <button class="minigame-button" id="minigameButton">¡Haz clic!</button>
            <p id="minigameCounter">0/10</p>
            <button class="minigame-button" id="minigameClose" style="display: none;">Cerrar</button>
        </div>
    </div>

    <div class="modal" id="nameModal">
        <div class="modal-content">
            <h2>¡Bienvenido a Telegotchi!</h2>
            <p>Elige un nombre para tu Telegotchi:</p>
            <input type="text" class="modal-input" id="petNameInput" maxlength="20"
                placeholder="Nombre de tu Telegotchi">
            <div>
                <button class="modal-button" id="confirmNameButton">Confirmar</button>
            </div>
        </div>
    </div>

    <div class="notification" id="notification"></div>

    <script>
        function drawUniqueCreature(canvasId, userId, level = 1, isAlive = true) {
            const canvas = document.getElementById(canvasId);
            canvas.height = 300;
            const ctx = canvas.getContext('2d');
            let time = 0;

            function hashCode(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    hash = str.charCodeAt(i) + ((hash << 5) - hash);
                    hash |= 0;
                }
                return Math.abs(hash);
            }

            function generateCreatureData(id, level) {
                const seed = hashCode(id);
                return {
                    bodyColor: `hsl(${seed % 360}, 70%, 60%)`,
                    eyeCount: 1 + (seed % 4) + Math.floor(level / 3),
                    eyeShape: seed % 3,
                    hornStyle: (seed + level) % 8,
                    size: 40 + (seed % 30) + level * 3,
                    mouthType: seed % 4,
                    tail: seed % 2 === 0 || level > 2,
                    wing: seed % 5 === 0 || level > 4,
                    antenna: level > 3 && (seed % 2 === 0),
                    pattern: level > 2,
                    blinkRate: 200 + (seed % 100),
                    cheeks: level > 1 && seed % 3 === 0,
                    accessory: level > 5 ? (seed % 6) : null,
                    earStyle: level > 6 ? (seed % 3) : null,
                    extraArms: level > 7 ? (seed % 2 === 0) : false,
                    tailStyle: level > 8 ? (seed % 3) : 0,
                    eyeColor: `hsl(${(seed * 7) % 360}, 80%, 70%)`
                };
            }

            let currentId = userId;
            let currentData = generateCreatureData(userId, level);

            function drawCreature(data, time = 0) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const bounce = isAlive ? Math.sin(time / 100) * 4 : 0;

                ctx.save();
                ctx.translate(0, bounce);

                // cuerpo
                ctx.fillStyle = data.bodyColor;
                ctx.beginPath();
                ctx.ellipse(centerX, centerY, data.size, data.size * 1.2, 0, 0, Math.PI * 2);
                ctx.fill();

                // patrón
                if (data.pattern && isAlive) {
                    ctx.strokeStyle = 'white';
                    for (let i = -3; i <= 3; i++) {
                        ctx.beginPath();
                        ctx.arc(centerX + i * 6, centerY + 5, 3, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                }

                // brazos extra
                if (data.extraArms && isAlive) {
                    ctx.strokeStyle = 'gray';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(centerX - data.size, centerY);
                    ctx.lineTo(centerX - data.size - 15, centerY + 20);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(centerX + data.size, centerY);
                    ctx.lineTo(centerX + data.size + 15, centerY + 20);
                    ctx.stroke();
                }

                // ojos
                const spacing = 18;
                const blinking = Math.floor(time / data.blinkRate) % 2 === 0;
                for (let i = 0; i < data.eyeCount; i++) {
                    const x = centerX - ((data.eyeCount - 1) * spacing) / 2 + i * spacing;
                    ctx.fillStyle = isAlive ? 'white' : '#444';
                    ctx.beginPath();
                    ctx.ellipse(x, centerY - 10, 8, blinking && isAlive ? 2 : 8, 0, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = isAlive ? data.eyeColor : 'black';
                    ctx.beginPath();
                    if (!isAlive) {
                        ctx.moveTo(x - 3, centerY - 13);
                        ctx.lineTo(x + 3, centerY - 7);
                        ctx.moveTo(x + 3, centerY - 13);
                        ctx.lineTo(x - 3, centerY - 7);
                        ctx.strokeStyle = 'black';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    } else if (!blinking) {
                        if (data.eyeShape === 0) ctx.arc(x, centerY - 10, 3, 0, Math.PI * 2);
                        else if (data.eyeShape === 1) ctx.rect(x - 2, centerY - 12, 4, 6);
                        else ctx.ellipse(x, centerY - 10, 2, 4, 0, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                // mejillas
                if (data.cheeks && isAlive) {
                    ctx.fillStyle = 'pink';
                    ctx.beginPath();
                    ctx.arc(centerX - 20, centerY + 5, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(centerX + 20, centerY + 5, 4, 0, Math.PI * 2);
                    ctx.fill();
                }

                // boca (muerta = cruz o nada)
                ctx.beginPath();
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                if (!isAlive) {
                    ctx.moveTo(centerX - 5, centerY + 20);
                    ctx.lineTo(centerX + 5, centerY + 20);
                } else if (data.mouthType === 0) ctx.arc(centerX, centerY + 20, 10, 0, Math.PI);
                else if (data.mouthType === 1) ctx.arc(centerX, centerY + 25, 10, Math.PI, 0);
                else if (data.mouthType === 2) {
                    ctx.moveTo(centerX - 8, centerY + 20);
                    ctx.lineTo(centerX + 8, centerY + 20);
                } else {
                    ctx.moveTo(centerX, centerY + 20);
                    ctx.lineTo(centerX, centerY + 30);
                }
                ctx.stroke();

                ctx.restore();
            }

            function animate() {
                drawCreature(currentData, time);
                time++;
                requestAnimationFrame(animate);
            }

            animate();
        }

        // Estado del juego
        const defaultGameState = {
            uniqueId: false,
            money: 50,
            hunger: 100,
            happiness: 100,
            energy: 100,
            cleanliness: 100,
            level: 1,
            xp: 0,
            collectedItems: {},
            petStage: 'egg',
            petName: 'Huevo Telegotchi',
            customName: false,
            workCooldown: false,
            sleepCooldown: false,
            lastUpdate: Date.now(),
            lastEvent: null,
            neglectTimer: {
                hunger: 0,
                happiness: 0,
                energy: 0,
                cleanliness: 0
            },
            deathWarningShown: false,
            isDead: false,
            deathReason: ''
        };

        let gameState = { ...defaultGameState };
        let currentMinigame = null;
        let saveInterval;
        let gameLoopInterval;

        // Elementos del DOM
        const petImage = document.getElementById('petImage');
        const petName = document.getElementById('petName');
        const petLevel = document.getElementById('petLevel');
        const moneyAmount = document.getElementById('moneyAmount');
        const hungerBar = document.getElementById('hungerBar');
        const happinessBar = document.getElementById('happinessBar');
        const energyBar = document.getElementById('energyBar');
        const cleanlinessBar = document.getElementById('cleanlinessBar');
        const feedButton = document.getElementById('feedButton');
        const playButton = document.getElementById('playButton');
        const workButton = document.getElementById('workButton');
        const sleepButton = document.getElementById('sleepButton');
        const cleanButton = document.getElementById('cleanButton');
        const shopButton = document.getElementById('shopButton');
        const eventButton = document.getElementById('eventButton');
        const reviveButton = document.getElementById('reviveButton');
        const resetButton = document.getElementById('resetButton');
        const shop = document.getElementById('shop');
        const collectionItems = document.getElementById('collectionItems');
        const notification = document.getElementById('notification');
        const petContainer = document.getElementById('petContainer');
        const actionButtons = document.getElementById('actionButtons');
        const deathScreen = document.getElementById('deathScreen');
        const deathMessage = document.getElementById('deathMessage');
        const tabs = document.querySelectorAll('.tab');
        const shopContents = document.querySelectorAll('.shop-content');
        const minigameContainer = document.getElementById('minigameContainer');
        const minigameTitle = document.getElementById('minigameTitle');
        const minigameDescription = document.getElementById('minigameDescription');
        const minigameProgress = document.getElementById('minigameProgress');
        const minigameButton = document.getElementById('minigameButton');
        const minigameCounter = document.getElementById('minigameCounter');
        const minigameClose = document.getElementById('minigameClose');
        const deathTimer = document.getElementById('deathTimer');
        const nameModal = document.getElementById('nameModal');
        const petNameInput = document.getElementById('petNameInput');
        const confirmNameButton = document.getElementById('confirmNameButton');

        // Configuración de etapas de la mascota
        const petStages = {
            egg: { emoji: '🥚', name: 'Huevo Telegotchi', nextXp: 100, minLevel: 1 },
            baby1: { emoji: '🐣', name: 'Bebé Telegotchi', nextXp: 300, minLevel: 2 },
            baby2: { emoji: '🐥', name: 'Telegotchi Niño', nextXp: 600, minLevel: 3 },
            teen1: { emoji: '🐤', name: 'Telegotchi Adolescente', nextXp: 1000, minLevel: 5 },
            teen2: { emoji: '🐦', name: 'Telegotchi Joven', nextXp: 1500, minLevel: 7 },
            adult1: { emoji: '🐔', name: 'Telegotchi Adulto', nextXp: 2100, minLevel: 10 },
            adult2: { emoji: '🦚', name: 'Telegotchi Majestuoso', nextXp: 2800, minLevel: 13 },
            elder: { emoji: '🦉', name: 'Telegotchi Sabio', nextXp: null, minLevel: 16 }
        };

        // Coleccionables disponibles
        const collectibles = [
            { id: 1, emoji: '🏆', name: 'Trofeo', price: 500 },
            { id: 2, emoji: '💎', name: 'Diamante', price: 1000 },
            { id: 3, emoji: '👑', name: 'Corona', price: 2000 },
            { id: 4, emoji: '🎮', name: 'Consola', price: 1500 },
            { id: 5, emoji: '🏡', name: 'Casa', price: 5000 }
        ];

        // Eventos diarios
        const dailyEvents = [
            {
                title: "¡Fiesta de Baile!",
                description: "Haz clic 10 veces para que tu Telegotchi baile y gane premios.",
                reward: { money: 50, happiness: 20, xp: 30 }
            },
            {
                title: "¡Carrera de Obstáculos!",
                description: "Haz clic rápidamente 15 veces para ayudar a tu Telegotchi a ganar la carrera.",
                reward: { money: 70, energy: 30, xp: 40 }
            },
            {
                title: "¡Concurso de Comida!",
                description: "Haz clic 12 veces para que tu Telegotchi coma rápido y gane el concurso.",
                reward: { money: 40, hunger: 30, xp: 25 }
            },
            {
                title: "¡Día de Spa!",
                description: "Haz clic 8 veces para darle un tratamiento de spa a tu Telegotchi.",
                reward: { money: 30, cleanliness: 50, happiness: 15, xp: 20 }
            }
        ];

        // Inicializar el juego
        function initGame() {

            loadGame();
            setupNameModalListeners(); // Añadir esta línea

            // Mostrar modal de nombre solo si es la primera vez o no tiene nombre personalizado
            if (!gameState.customName) {
                showNameModal();
            } else {
                setupGame();
            }
        }

        // Configurar el juego después de establecer el nombre
        function setupGame() {
            updateUI();
            setupEventListeners();
            startGameLoop();
            checkDailyEvent();
            // Actualizar imagen de la mascota
            updatePetImage();
            // Guardar constantemente cada 5 segundos
            saveInterval = setInterval(saveGame, 5000);
        }

        // Mostrar modal para elegir nombre
        function showNameModal() {
            nameModal.style.display = 'flex';
            petNameInput.focus();
        }

        // Cerrar modal de nombre
        function closeNameModal() {
            nameModal.style.display = 'none';
        }

        // Cargar el juego guardado
        function loadGame() {
            const savedGame = localStorage.getItem('telegotchiGame');
            if (savedGame) {
                const parsedGame = JSON.parse(savedGame);
                // Resetear workCooldown si el tiempo de cooldown ya pasó
                if (parsedGame.workCooldown) {
                    const now = Date.now();
                    const cooldownEnd = parsedGame.lastUpdate + 10000; // 10 segundos de cooldown
                    if (now > cooldownEnd) {
                        parsedGame.workCooldown = false;
                    }
                }


                // Calcular el tiempo transcurrido desde la última actualización
                const now = Date.now();
                const timeElapsed = Math.floor((now - parsedGame.lastUpdate) / 1000); // en segundos

                // Solo aplicar degradación si no está muerto
                if (!parsedGame.isDead && timeElapsed > 0) {
                    const minutesElapsed = Math.floor(timeElapsed / 60);
                    const hoursElapsed = Math.floor(minutesElapsed / 60);

                    // Degradación por hora transcurrida (más lento que antes)
                    parsedGame.hunger = Math.max(0, parsedGame.hunger - hoursElapsed * 5);
                    parsedGame.happiness = Math.max(0, parsedGame.happiness - hoursElapsed * 3);
                    parsedGame.energy = Math.max(0, parsedGame.energy - hoursElapsed * 4);
                    parsedGame.cleanliness = Math.max(0, parsedGame.cleanliness - hoursElapsed * 3);

                    // Actualizar temporizador de negligencia
                    updateNeglectTimer(parsedGame, hoursElapsed);

                    // Añadir XP por tiempo sobrevivido (más lento que antes)
                    if (parsedGame.hunger > 0 && parsedGame.happiness > 0) {
                        parsedGame.xp += hoursElapsed * 2;
                    }
                }

                parsedGame.lastUpdate = now;
                gameState = parsedGame;

                // Si está muerto, mostrar pantalla de muerte
                if (gameState.isDead) {
                    showDeathScreen();
                }
            }
        }

        // Guardar el estado del juego
        function saveGame() {
            gameState.lastUpdate = Date.now();
            localStorage.setItem('telegotchiGame', JSON.stringify(gameState));
        }

        // Configurar event listeners
        function setupEventListeners() {
            // Botones de acciones
            feedButton.addEventListener('click', feedPet);
            playButton.addEventListener('click', playWithPet);
            workButton.addEventListener('click', work);
            sleepButton.addEventListener('click', putToSleep);
            cleanButton.addEventListener('click', cleanPet);
            shopButton.addEventListener('click', toggleShop);
            eventButton.addEventListener('click', startDailyEvent);
            reviveButton.addEventListener('click', revivePet);
            resetButton.addEventListener('click', resetGame);
            confirmNameButton.addEventListener('click', setPetName);

            // Tabs de la tienda
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    tabs.forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');

                    const tabId = tab.getAttribute('data-tab');
                    shopContents.forEach(content => {
                        content.classList.remove('active');
                        if (content.id === `${tabId}-shop`) {
                            content.classList.add('active');
                        }
                    });
                });
            });

            // Delegación de eventos para los botones de compra
            shop.addEventListener('click', function (e) {
                if (e.target.classList.contains('buy-item')) {
                    const type = e.target.getAttribute('data-type');
                    const cost = parseInt(e.target.getAttribute('data-cost'));

                    if (type === 'collectible') {
                        const id = parseInt(e.target.getAttribute('data-id'));
                        buyCollectible(cost, id);
                    } else {
                        const value = parseInt(e.target.getAttribute('data-value'));
                        const hunger = e.target.hasAttribute('data-hunger') ? parseInt(e.target.getAttribute('data-hunger')) : 0;
                        const happiness = e.target.hasAttribute('data-happiness') ? parseInt(e.target.getAttribute('data-happiness')) : 0;
                        const cleanliness = e.target.hasAttribute('data-cleanliness') ? parseInt(e.target.getAttribute('data-cleanliness')) : 0;

                        buyItem(type, cost, value, { hunger, happiness, cleanliness });
                    }
                }
            });

            // Minijuego
            minigameButton.addEventListener('click', progressMinigame);
            minigameClose.addEventListener('click', closeMinigame);

            // Guardar el juego antes de cerrar la página
            window.addEventListener('beforeunload', saveGame);
        }

        // Establecer nombre de la mascota
        function setPetName() {
            const name = petNameInput.value.trim();
            if (name.length > 0) {
                gameState.petName = name;
                gameState.customName = true;
                petName.textContent = name;
                closeNameModal();
                setupGame();
                saveGame();
                showNotification(`¡Bienvenido ${name}!`, 'warning');
            } else {
                showNotification('Por favor ingresa un nombre válido', 'error');
                petNameInput.focus();
            }
        }

        // Bucle principal del juego
        function startGameLoop() {
            // Limpiar cualquier intervalo existente
            if (gameLoopInterval) clearInterval(gameLoopInterval);

            gameLoopInterval = setInterval(() => {
                // Solo actualizar si no está muerto
                if (!gameState.isDead) {
                    // Disminuir estadísticas con el tiempo (más lento que antes)
                    gameState.hunger = Math.max(0, gameState.hunger - 0.2);
                    gameState.happiness = Math.max(0, gameState.happiness - 0.1);
                    gameState.energy = Math.max(0, gameState.energy - 0.15);
                    gameState.cleanliness = Math.max(0, gameState.cleanliness - 0.1);

                    // Actualizar temporizador de negligencia
                    updateNeglectTimer(gameState, 0.016); // ~1 minuto en el juego

                    // Añadir un poco de XP por sobrevivir (más lento que antes)
                    if (gameState.hunger > 0 && gameState.happiness > 0) {
                        gameState.xp += 0.2;
                    }

                    // Calcular nivel basado en XP (más difícil subir de nivel)
                    const newLevel = Math.floor(Math.sqrt(gameState.xp / 10)) + 1;
                    if (newLevel > gameState.level) {
                        gameState.level = newLevel;
                        showNotification(`¡Subiste al nivel ${gameState.level}!`, 'warning');
                    }

                    // Verificar evolución
                    checkEvolution();

                    // Verificar si la mascota murió
                    checkPetHealth();

                    updateUI();
                }
            }, 3000);
        }

        // Verificar evento diario
        function checkDailyEvent() {
            const now = new Date();
            const today = now.toDateString();

            if (!gameState.lastEvent || gameState.lastEvent !== today) {
                gameState.lastEvent = today;
                eventButton.style.display = 'block';
            }
        }

        // Iniciar evento diario
        function startDailyEvent() {
            const randomEvent = dailyEvents[Math.floor(Math.random() * dailyEvents.length)];
            currentMinigame = {
                ...randomEvent,
                progress: 0,
                required: randomEvent.title.includes("15") ? 15 :
                    randomEvent.title.includes("12") ? 12 :
                        randomEvent.title.includes("10") ? 10 : 8
            };

            minigameTitle.textContent = randomEvent.title;
            minigameDescription.textContent = randomEvent.description;
            minigameProgress.style.width = '0%';
            minigameCounter.textContent = `0/${currentMinigame.required}`;
            minigameClose.style.display = 'none';
            minigameButton.style.display = 'block';

            minigameContainer.style.display = 'flex';
        }

        // Progresar en el minijuego
        function progressMinigame() {
            if (currentMinigame) {
                currentMinigame.progress++;
                const progressPercent = (currentMinigame.progress / currentMinigame.required) * 100;
                minigameProgress.style.width = `${progressPercent}%`;
                minigameCounter.textContent = `${currentMinigame.progress}/${currentMinigame.required}`;

                if (currentMinigame.progress >= currentMinigame.required) {
                    completeMinigame();
                }
            }
        }

        // Completar minijuego
        function completeMinigame() {
            if (currentMinigame) {
                // Dar recompensas
                if (currentMinigame.reward.money) gameState.money += currentMinigame.reward.money;
                if (currentMinigame.reward.hunger) gameState.hunger = Math.min(100, gameState.hunger + currentMinigame.reward.hunger);
                if (currentMinigame.reward.happiness) gameState.happiness = Math.min(100, gameState.happiness + currentMinigame.reward.happiness);
                if (currentMinigame.reward.energy) gameState.energy = Math.min(100, gameState.energy + currentMinigame.reward.energy);
                if (currentMinigame.reward.cleanliness) gameState.cleanliness = Math.min(100, gameState.cleanliness + currentMinigame.reward.cleanliness);
                if (currentMinigame.reward.xp) gameState.xp += currentMinigame.reward.xp;

                minigameTitle.textContent = "¡Completado!";
                minigameDescription.textContent = `Has ganado: $${currentMinigame.reward.money || 0}, ${currentMinigame.reward.xp} XP y más!`;
                minigameButton.style.display = 'none';
                minigameClose.style.display = 'block';

                eventButton.style.display = 'none';
                updateUI();
                saveGame();
            }
        }

        // Cerrar minijuego
        function closeMinigame() {
            minigameContainer.style.display = 'none';
        }

        // Mostrar pantalla de muerte
        function showDeathScreen() {
            actionButtons.style.display = 'none';
            deathScreen.style.display = 'block';

            if (gameState.deathReason === 'neglect') {
                deathMessage.textContent = "Tu Telegotchi murió por falta de cuidado. ¡Debes estar más atento la próxima vez!";
            } else {
                deathMessage.textContent = "Tu Telegotchi ha muerto. ¡Cuida mejor al próximo!";
            }

            // Deshabilitar botón de revivir si no hay suficiente dinero
            reviveButton.disabled = gameState.money < 1000;
        }

        // Ocultar pantalla de muerte
        function hideDeathScreen() {
            actionButtons.style.display = 'grid';
            deathScreen.style.display = 'none';
        }

        // Revivir mascota
        function revivePet() {
            if (gameState.money >= 1000) {
                gameState.money -= 1000;
                gameState.isDead = false;
                // Actualizar imagen de la mascota
                updatePetImage();
                gameState.hunger = 80;
                gameState.happiness = 80;
                gameState.energy = 80;
                gameState.cleanliness = 80;
                gameState.neglectTimer = {
                    hunger: 0,
                    happiness: 0,
                    energy: 0,
                    cleanliness: 0
                };

                hideDeathScreen();
                showNotification('¡Tu Telegotchi ha revivido! -$1000', 'warning');
                updateUI();
                saveGame();
            }
        }

        // Reiniciar juego
        function resetGame() {
            // Guardar el nombre personalizado si existe
            const customName = gameState.customName ? gameState.petName : false;

            // Resetear estado del juego
            gameState = { ...defaultGameState };

            // Mantener el nombre personalizado si existía
            if (customName) {
                gameState.petName = customName;
                gameState.customName = true;
            }

            hideDeathScreen();
            updateUI();
            saveGame();

            // Reiniciar el bucle del juego
            startGameLoop();

            showNotification('¡Has comenzado un nuevo juego!', 'warning');
        }

        // Actualizar la interfaz de usuario
        function updateUI() {
            moneyAmount.textContent = Math.floor(gameState.money);
            hungerBar.style.width = `${Math.floor(gameState.hunger)}%`;
            happinessBar.style.width = `${Math.floor(gameState.happiness)}%`;
            energyBar.style.width = `${Math.floor(gameState.energy)}%`;
            cleanlinessBar.style.width = `${Math.floor(gameState.cleanliness)}%`;
            petLevel.textContent = gameState.level;
            petName.textContent = gameState.petName;

            // Actualizar colores de las barras según los valores
            updateBarColor(hungerBar, gameState.hunger, '#ff9800');
            updateBarColor(happinessBar, gameState.happiness, '#e91e63');
            updateBarColor(energyBar, gameState.energy, '#2196f3');
            updateBarColor(cleanlinessBar, gameState.cleanliness, '#9c27b0');

            // Deshabilitar botones según el estado
            feedButton.disabled = gameState.money < 10 || gameState.hunger >= 100 || gameState.isDead;
            cleanButton.disabled = gameState.money < 5 || gameState.cleanliness >= 100 || gameState.isDead;
            workButton.disabled = gameState.workCooldown || gameState.energy <= 0 || gameState.isDead;
            playButton.disabled = gameState.energy <= 0 || gameState.isDead;
            sleepButton.disabled = gameState.sleepCooldown || gameState.energy >= 100 || gameState.isDead;
            shopButton.disabled = gameState.isDead;

            // Actualizar texto de botones
            workButton.textContent = gameState.workCooldown ? 'Descansando...' : 'Trabajar (+$15)';
            sleepButton.textContent = gameState.sleepCooldown ? 'Despertando...' : 'Dormir';

            // Actualizar temporizador de muerte
            updateDeathTimerDisplay();

            // Actualizar colección
            updateCollectionDisplay();
        }

        // Actualizar imagen de la mascota según su estado
        function updatePetImage() {
            if (window.Telegram?.WebApp?.initDataUnsafe?.user) {
                const user = Telegram.WebApp.initDataUnsafe.user;
                const userId = user.id;
                gameState.uniqueId = userId;
                drawUniqueCreature("creatureCanvas", gameState.uniqueId, gameState.level, !gameState.isDead);
            }
            else {
                if (!gameState.uniqueId) {
                    function generarSemillaUnica() {
                        // 1. Base: Fecha y hora actual en milisegundos
                        const fechaActual = Date.now();

                        // 2. Precisión extra (usando Performance API en navegadores)
                        let precisionExtra = 0;
                        if (typeof performance !== 'undefined' && performance.now) {
                            precisionExtra = performance.now() * 1000; // Microsegundos
                        }

                        // 3. Aleatoriedad segura (crypto) o fallback a Math.random
                        let componenteAleatorio;
                        if (typeof crypto !== 'undefined' && crypto.getRandomValues) {
                            const array = new Uint32Array(1);
                            crypto.getRandomValues(array);
                            componenteAleatorio = array[0];
                        } else {
                            componenteAleatorio = Math.floor(Math.random() * 0xFFFFFFFF);
                        }

                        // Combinamos todo (usando XOR para mezclar bits)
                        const semilla = fechaActual ^ precisionExtra ^ componenteAleatorio;
                        return semilla;
                    }
                    class GeneradorAleatorioConSemilla {
                        constructor(semilla) {
                            this.semilla = semilla || 12345; // Semilla por defecto si no se provee
                        }

                        // Algoritmo Lehmer (MINSTD)
                        next() {
                            this.semilla = (this.semilla * 48271) % 0x7FFFFFFF;
                            return this.semilla / 0x7FFFFFFF; // Normalizado a [0, 1)
                        }

                        // Entero entre [min, max] (ambos incluidos)
                        nextInt(min, max) {
                            return Math.floor(this.next() * (max - min + 1)) + min;
                        }
                    }
                    // 1. Generar semilla única
                    const semilla = generarSemillaUnica();
                    

                    // 2. Crear generador con esa semilla
                    const rng = new GeneradorAleatorioConSemilla(semilla);

                    // 3. Generar números aleatorios reproducibles
                    
                    console.log(rng.nextInt(1, 100)); // Ej: 42 (entre 1 y 100)
                    gameState.uniqueId = toString(rng.nextInt(1000000000,9999999999))
                }
                drawUniqueCreature("creatureCanvas", gameState.uniqueId, gameState.level, !gameState.isDead);
            }
        }

        // Actualizar color de una barra según su valor
        function updateBarColor(bar, value, midColor) {
            if (value < 30) {
                bar.style.backgroundColor = '#f44336';
            } else if (value < 70) {
                bar.style.backgroundColor = midColor;
            } else {
                bar.style.backgroundColor = '#4caf50';
            }
        }

        // Actualizar display del temporizador de muerte
        function updateDeathTimerDisplay() {
            if (gameState.isDead) return;

            const maxNeglect = Math.max(
                gameState.neglectTimer.hunger,
                gameState.neglectTimer.happiness,
                gameState.neglectTimer.energy,
                gameState.neglectTimer.cleanliness
            );

            const remainingHours = 30 - maxNeglect;

            if (maxNeglect > 20) {
                deathTimer.textContent = `⚠️ Peligro: Muerte en ~${remainingHours}h`;
                deathTimer.className = 'death-timer warning';

                if (!gameState.deathWarningShown) {
                    showNotification('¡Tu Telegotchi está en peligro! Cuídalo pronto o morirá.', 'error');
                    gameState.deathWarningShown = true;
                }
            } else if (maxNeglect > 10) {
                deathTimer.textContent = `Cuidado: Necesita atención (~${remainingHours}h restantes)`;
                deathTimer.className = 'death-timer';
                gameState.deathWarningShown = false;
            } else if (maxNeglect > 0) {
                deathTimer.textContent = `Saludable (${remainingHours}h de seguridad)`;
                deathTimer.className = 'death-timer';
                gameState.deathWarningShown = false;
            } else {
                deathTimer.textContent = '';
                deathTimer.className = 'death-timer';
                gameState.deathWarningShown = false;
            }
        }

        // Alimentar a la mascota
        function feedPet() {
            if (gameState.money >= 10 && gameState.hunger < 100 && !gameState.isDead) {
                gameState.money -= 10;
                gameState.hunger = Math.min(100, gameState.hunger + 20);
                gameState.xp += 5;
                gameState.cleanliness = Math.max(0, gameState.cleanliness - 5);
                gameState.neglectTimer.hunger = Math.max(0, gameState.neglectTimer.hunger - 10);
                showNotification('¡Tu Telegotchi ha comido! +20 hambre, -5 limpieza');
                updateUI();
                saveGame();
            }
        }

        // Jugar con la mascota
        function playWithPet() {
            if (gameState.energy > 0 && !gameState.isDead) {
                gameState.happiness = Math.min(100, gameState.happiness + 15);
                gameState.energy = Math.max(0, gameState.energy - 20);
                gameState.xp += 10;
                gameState.cleanliness = Math.max(0, gameState.cleanliness - 10);
                gameState.neglectTimer.happiness = Math.max(0, gameState.neglectTimer.happiness - 10);
                showNotification('¡Tu Telegotchi se divirtió jugando! +15 felicidad, -20 energía, -10 limpieza');
                updateUI();
                saveGame();
            }
        }
        function work() {
            // Trabajar para ganar dinero
            if (!gameState.workCooldown && gameState.energy > 0 && !gameState.isDead) {
                gameState.money += 15;
                gameState.happiness = Math.max(0, gameState.happiness - 5);
                gameState.energy = Math.max(0, gameState.energy - 30);
                gameState.workCooldown = true;
                gameState.neglectTimer.energy = Math.max(0, gameState.neglectTimer.energy - 5);
                gameState.lastUpdate = Date.now(); // Actualizar timestamp

                showNotification('+$15 por trabajar. -5 felicidad, -30 energía');
                updateUI();
                saveGame();

                // Cooldown de trabajo
                setTimeout(() => {
                    gameState.workCooldown = false;
                    updateUI();
                    saveGame();
                }, 10000);
            }
        }
        // Poner a dormir a la mascota
        function putToSleep() {
            if (!gameState.sleepCooldown && gameState.energy < 100 && !gameState.isDead) {
                gameState.sleepCooldown = true;
                sleepButton.textContent = 'Durmiendo...';
                gameState.neglectTimer.energy = Math.max(0, gameState.neglectTimer.energy - 15);

                // Recuperar energía gradualmente
                const sleepInterval = setInterval(() => {
                    gameState.energy = Math.min(100, gameState.energy + 10);
                    updateUI();
                    saveGame();

                    if (gameState.energy >= 100 || gameState.isDead) {
                        clearInterval(sleepInterval);
                        gameState.sleepCooldown = false;

                        if (!gameState.isDead) {
                            showNotification('¡Tu Telegotchi descansó bien! Energía al máximo');
                        }

                        updateUI();
                        saveGame();
                    }
                }, 2000);
            }
        }

        // Limpiar a la mascota
        function cleanPet() {
            if (gameState.money >= 5 && gameState.cleanliness < 100 && !gameState.isDead) {
                gameState.money -= 5;
                gameState.cleanliness = Math.min(100, gameState.cleanliness + 30);
                gameState.xp += 3;
                gameState.neglectTimer.cleanliness = Math.max(0, gameState.neglectTimer.cleanliness - 10);
                showNotification('¡Tu Telegotchi está limpio! +30 limpieza');
                updateUI();
                saveGame();
            }
        }

        // Comprar ítem de la tienda
        function buyItem(type, cost, value, sideEffects = {}) {
            if (gameState.money >= cost && !gameState.isDead) {
                gameState.money -= cost;

                switch (type) {
                    case 'food':
                        gameState.hunger = Math.min(100, gameState.hunger + value);
                        gameState.neglectTimer.hunger = Math.max(0, gameState.neglectTimer.hunger - 5);
                        break;
                    case 'energy':
                        gameState.energy = Math.min(100, gameState.energy + value);
                        gameState.neglectTimer.energy = Math.max(0, gameState.neglectTimer.energy - 5);
                        break;
                    case 'cleanliness':
                        gameState.cleanliness = Math.min(100, gameState.cleanliness + value);
                        gameState.neglectTimer.cleanliness = Math.max(0, gameState.neglectTimer.cleanliness - 5);
                        break;
                }

                // Aplicar efectos secundarios
                if (sideEffects.hunger) {
                    gameState.hunger = Math.max(0, Math.min(100, gameState.hunger + sideEffects.hunger));
                    if (sideEffects.hunger > 0) gameState.neglectTimer.hunger = Math.max(0, gameState.neglectTimer.hunger - 5);
                }
                if (sideEffects.happiness) {
                    gameState.happiness = Math.max(0, Math.min(100, gameState.happiness + sideEffects.happiness));
                    if (sideEffects.happiness > 0) gameState.neglectTimer.happiness = Math.max(0, gameState.neglectTimer.happiness - 5);
                }
                if (sideEffects.cleanliness) {
                    gameState.cleanliness = Math.max(0, Math.min(100, gameState.cleanliness + sideEffects.cleanliness));
                    if (sideEffects.cleanliness > 0) gameState.neglectTimer.cleanliness = Math.max(0, gameState.neglectTimer.cleanliness - 5);
                }

                gameState.xp += 8;

                let message = `¡${type === 'food' ? 'Comida' : type === 'energy' ? 'Energía' : 'Limpieza'} comprada! +${value} ${type}`;
                if (sideEffects.hunger) message += `, ${sideEffects.hunger > 0 ? '+' : ''}${sideEffects.hunger} hambre`;
                if (sideEffects.happiness) message += `, ${sideEffects.happiness > 0 ? '+' : ''}${sideEffects.happiness} felicidad`;
                if (sideEffects.cleanliness) message += `, ${sideEffects.cleanliness > 0 ? '+' : ''}${sideEffects.cleanliness} limpieza`;

                showNotification(message);
                updateUI();
                saveGame();
            } else {
                showNotification(gameState.isDead ? 'No puedes comprar mientras tu Telegotchi está muerto' : 'No tienes suficiente dinero', 'error');
            }
        }

        // Comprar coleccionable
        function buyCollectible(cost, id) {
            if (gameState.money >= cost && !gameState.isDead) {
                if (!gameState.collectedItems[id]) {
                    gameState.money -= cost;
                    gameState.collectedItems[id] = 1;
                    gameState.xp += 50;
                    showNotification('¡Coleccionable adquirido! +50 XP');
                    updateUI();
                    saveGame();
                } else {
                    gameState.money -= cost;
                    gameState.collectedItems[id]++;
                    gameState.xp += 20;
                    showNotification(`¡Otro ${collectibles.find(c => c.id === id).name} para tu colección! +20 XP`);
                    updateUI();
                    saveGame();
                }
            } else {
                showNotification(gameState.isDead ? 'No puedes comprar mientras tu Telegotchi está muerto' : 'No tienes suficiente dinero', 'error');
            }
        }

        // Mostrar/ocultar tienda
        function toggleShop() {
            shop.style.display = shop.style.display === 'block' ? 'none' : 'block';
        }

        // Verificar evolución de la mascota
        function checkEvolution() {
            const currentStage = petStages[gameState.petStage];

            // Verificar si hay una próxima etapa y si se cumplen los requisitos
            if (currentStage.nextXp && gameState.xp >= currentStage.nextXp && gameState.level >= currentStage.minLevel) {
                // Encontrar la próxima etapa
                const stages = Object.keys(petStages);
                const currentIndex = stages.indexOf(gameState.petStage);

                if (currentIndex < stages.length - 1) {
                    const nextStage = stages[currentIndex + 1];

                    // Verificar requisitos de nivel para la próxima etapa
                    if (gameState.level >= petStages[nextStage].minLevel) {
                        gameState.petStage = nextStage;
                        gameState.petName = gameState.customName ? gameState.petName : petStages[nextStage].name;

                        // Mostrar animación de evolución
                        showEvolutionAnimation(petStages[nextStage].emoji);

                        showNotification(`¡Tu Telegotchi ha evolucionado a ${petStages[nextStage].name}!`, 'warning');
                        saveGame();
                    }
                }
            }
        }

        // Verificar salud de la mascota
        function checkPetHealth() {
            // Verificar si alguna estadística está en 0
            if (gameState.hunger <= 0 || gameState.happiness <= 0 || gameState.energy <= 0 || gameState.cleanliness <= 0) {
                gameState.isDead = true;
                // Actualizar imagen de la mascota
                updatePetImage();
                gameState.deathReason = 'stats';
                showDeathScreen();
                showNotification('¡Tu Telegotchi ha muerto!', 'error');
                saveGame();
                return true;
            }

            // Verificar negligencia (30 horas con alguna estadística baja)
            const maxNeglect = Math.max(
                gameState.neglectTimer.hunger,
                gameState.neglectTimer.happiness,
                gameState.neglectTimer.energy,
                gameState.neglectTimer.cleanliness
            );

            if (maxNeglect >= 30) {
                gameState.isDead = true;
                // Actualizar imagen de la mascota
                updatePetImage();
                gameState.deathReason = 'neglect';
                showDeathScreen();
                showNotification('¡Tu Telegotchi murió por falta de cuidado!', 'error');
                saveGame();
                return true;
            }

            return false;
        }

        // Mostrar animación de evolución
        function showEvolutionAnimation(newEmoji) {
            const evolutionDiv = document.createElement('div');
            evolutionDiv.className = 'pet-evolution';
            evolutionDiv.innerHTML = `
                <div class="pet-image"><canvas id="evo-animation"></div>
                <h2>¡Evolucionando!</h2>
                <p>${gameState.petName}</p>
            `;

            petContainer.appendChild(evolutionDiv);

            if (window.Telegram?.WebApp?.initDataUnsafe?.user) {
                const user = Telegram.WebApp.initDataUnsafe.user;
                const userId = user.id;
                drawUniqueCreature("evo-animation", userId, gameState.level, !gameState.isDead)
            }

            // Eliminar la animación después de 3 segundos
            setTimeout(() => {
                petContainer.removeChild(evolutionDiv);

            }, 3000);
        }

        // Actualizar visualización de la colección
        function updateCollectionDisplay() {
            collectionItems.innerHTML = '';

            collectibles.forEach(item => {
                const itemDiv = document.createElement('div');
                itemDiv.className = `collection-item ${gameState.collectedItems[item.id] ? 'owned' : ''}`;
                itemDiv.textContent = item.emoji;
                itemDiv.title = gameState.collectedItems[item.id] ? `${item.name} (x${gameState.collectedItems[item.id]})` : '???';

                if (gameState.collectedItems[item.id]) {
                    const countDiv = document.createElement('div');
                    countDiv.className = 'collection-count';
                    countDiv.textContent = gameState.collectedItems[item.id];
                    itemDiv.appendChild(countDiv);
                }

                collectionItems.appendChild(itemDiv);
            });
        }

        // Mostrar notificación
        function showNotification(message, type = 'success') {
            notification.textContent = message;
            notification.className = 'notification';

            if (type === 'error') {
                notification.classList.add('error');
            } else if (type === 'warning') {
                notification.classList.add('warning');
            } else {
                notification.classList.remove('error');
                notification.classList.remove('warning');
            }

            notification.classList.add('show');

            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }

        // Actualizar temporizador de negligencia
        function updateNeglectTimer(state, hoursElapsed) {
            // Tiempo máximo de negligencia (30 horas)
            const maxNeglect = 30;

            // Actualizar temporizadores para cada estadística
            if (state.hunger <= 30) state.neglectTimer.hunger = Math.min(maxNeglect, state.neglectTimer.hunger + hoursElapsed);
            else state.neglectTimer.hunger = Math.max(0, state.neglectTimer.hunger - hoursElapsed * 2);

            if (state.happiness <= 30) state.neglectTimer.happiness = Math.min(maxNeglect, state.neglectTimer.happiness + hoursElapsed);
            else state.neglectTimer.happiness = Math.max(0, state.neglectTimer.happiness - hoursElapsed * 2);

            if (state.energy <= 30) state.neglectTimer.energy = Math.min(maxNeglect, state.neglectTimer.energy + hoursElapsed);
            else state.neglectTimer.energy = Math.max(0, state.neglectTimer.energy - hoursElapsed * 2);

            if (state.cleanliness <= 30) state.neglectTimer.cleanliness = Math.min(maxNeglect, state.neglectTimer.cleanliness + hoursElapsed);
            else state.neglectTimer.cleanliness = Math.max(0, state.neglectTimer.cleanliness - hoursElapsed * 2);
        }
        function setupNameModalListeners() {
            confirmNameButton.addEventListener('click', setPetName);

            // Permitir confirmar con Enter
            petNameInput.addEventListener('keypress', function (e) {
                if (e.key === 'Enter') {
                    setPetName();
                }
            });
        }
        // Iniciar el juego cuando se cargue la página
        window.addEventListener('load', initGame);
    </script>
</body>

</html>